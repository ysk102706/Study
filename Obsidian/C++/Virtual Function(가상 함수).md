가상 함수는 파생 클래스에서 재정의할 것으로 기대하는 멤버 함수를 의미한다. 
이런 가상 함수는 virtual 키워드를 통해서 선언되며, 자신을 호출하는 객체의 동적 타입에 따라서 실제 호출할 함수가 결정된다. 
```cpp 
virtual void Func();
``` 

대부분의 함수를 호출하는 코드는 컴파일 타임에 고정된 메모리 주소로 변환되며, 이것을 정적 바인딩이라고 한다. 

하지만 가상 함수의 호출은 컴파일러가 어떤 함수를 호출해야 하는지 미리 알 수 없기 때문에 런타임에 함수가 실행되도록 하는데, 이것을 동적 바인딩이라고 한다. 
- 가상 함수도 결합하는 타입이 분명할 때는 일반 함수처럼 정적 바인딩을 한다. 

컴파일러가 가상 함수를 다루는 가장 일반적인 방식은 가상 함수 테이블을 이용하는 것이다. 컴파일러는 각각의 객체마다 가상 함수 테이블을 가리키는 포인터를 저장하기 위한 숨겨진 멤버를 하나씩 추가하며, 가상 함수를 단 하나라도 가지는 클래스에 대해서 가상 함수 테이블을 작성한다. 
- 작성된 가상 함수 테이블에는 해당 클래스의 객체들에 선언된 가상 함수들의 주소가 저장된다. 

```cpp
class A {...};
class B : public A {...};

A* test = new B;
delete test;
```
위와 같은 상황에서 delete test는 A의 소멸자를 호출할 것이다. 그렇게 되면 B 객체에 동적으로 할당된 메모리는 정상적으로 해제되지 않을 것이다. 

이때 A의 소멸자를 virtual 키워드를 통해서 선언하게 되면, 위의 구문은 B의 소멸자를 호출하면서 정상적으로 동작할 것이다. 

### Pure Virtual Function(순수 가상 함수) 
가상 함수는 파생 클래스에서 반드시 재정의를 해야하는 것은 아니다. 이와 달리 순수 가상 함수는 파생 클래스에서 반드시 재정의를 해주어야 한다. 
```cpp
virtual void Test() = 0;
```

